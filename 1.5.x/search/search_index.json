{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":""},{"location":"#our-mission","title":"Our Mission","text":"<p>With CitrineOS, our mission is to drive the transformation of the EV charging landscape, making it more attainable, equitable, and diverse than ever before. For over a decade, our parent company, S44, has been at the forefront of EV charging software, powering automotive OEMs and leading EV network operators. Now, through CitrineOS, we are taking a giant leap forward in advancing the adoption of electric vehicles and diversifying the EV charging infrastructure worldwide.</p>"},{"location":"#who-we-are","title":"Who We Are","text":"<p>CitrineOS, created by S44, is the brainchild of a dedicated team with deep expertise in EV charging technology. We understand the critical role that reliable back-end software plays in the world of EV charging. Our commitment to innovation and inclusivity drives us to make our solutions accessible to everyone.</p>"},{"location":"#what-we-offer","title":"What We Offer","text":"<p>CitrineOS is more than just software; it's a catalyst for change. We are proud to offer our Open Charge Point Protocol (OCPP) 2.0.1 open source software on GitHub. This groundbreaking platform empowers a wide range of stakeholders, from passionate EV enthusiasts to the most prominent charge point operators, fleet managers, and automotive manufacturers.</p>"},{"location":"#with-citrineos-you-can","title":"With CitrineOS, you can:","text":"<ol> <li> <p>Provision New Charging Equipment: Seamlessly set up new charging stations, ensuring they're ready for action.</p> </li> <li> <p>Complete Charging Transactions: Enable secure and efficient EV charging experiences for users.</p> </li> <li> <p>Remotely Control Charging Equipment: Take charge of your charging infrastructure from anywhere, ensuring optimal performance.</p> </li> <li> <p>Monitor Charger Equipment Uptime, Power Levels, and Degradation: Keep a close eye on the health and efficiency of your charging stations.</p> </li> <li> <p>Manage Energy Consumption and Throughput: Optimize energy use and throughput, reducing environmental impact.</p> </li> </ol>"},{"location":"#how-we-do-it","title":"How We Do It","text":"<p>Our modular software is meticulously designed based on real-world EV charging use cases. We understand the pressing need to enhance reliability and interoperability in EV charging ecosystems. CitrineOS is the ideal solution for achieving rapid compliance with National EV Infrastructure (NEVI) standards in both new and existing environments.</p>"},{"location":"#why-it-matters","title":"Why It Matters","text":"<p>CitrineOS offers a multitude of benefits:</p> <ol> <li> <p>Rapid Deployment: Set up a single charging point or an entire network 90% faster, ensuring that EV charging infrastructure keeps pace with the surging demand.</p> </li> <li> <p>NEVI Compliance: Meet aggressive federal NEVI timelines and standards for funding, securing essential resources to expand EV network.</p> </li> <li> <p>Future-Proofing: Avoid the pitfalls of vendor lock-in, ensuring that the charging network remains adaptable to evolving industry standards.</p> </li> <li> <p>Cost Efficiency: Reduce runtime and operational costs by leveraging our cloud microservices architecture, streamlining management and maintenance.</p> </li> <li> <p>Interoperability: Embrace widespread interoperability, fostering seamless connections between various charging stations and CSMS.</p> </li> <li> <p>Reliability: Enhance reliability across the board with our common open source software backend.</p> </li> </ol>"},{"location":"#differentiator","title":"Differentiator","text":"<p>In a world where proprietary solutions dominate the landscape, CitrineOS stands out as the first and only platform that offers a common, open source software foundation for all. Whether you're a passionate EV enthusiast or a major charge point operator, CitrineOS is your gateway to accelerate CPO deployments, future-proof your EV charging network, and ultimately contribute to a more sustainable and equitable future powered by electric vehicles.</p> <p>Join us in revolutionizing the EV charging ecosystem \u2013 together, we'll drive change for a cleaner, brighter tomorrow.</p>"},{"location":"references/","title":"References","text":""},{"location":"references/#references","title":"References","text":"<p>Want to read more about what we based our project on? Take a look at the following urls: - OCPP 2.0.1 - OCTT (OCPP Testing tool)</p>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#roadmap","title":"Roadmap","text":""},{"location":"roadmap/#current-version","title":"Current Version","text":"<ul> <li>Version: 1.5.X</li> <li>Highlights: Operator UI launched! Changes in citrineos-core made to support it.</li> <li>Ongoing Work: Stable release. Currently pursuing OCA Certification for this version for the Core and Advance Security certification profiles.</li> </ul>"},{"location":"roadmap/#next-release","title":"Next Release","text":"<ul> <li>Target Version: 1.6.0</li> <li>Estimated Release Date: 2025-01-31</li> <li>Features &amp; Improvements:</li> <li>Operator UI: Dashboard, Location &amp; Station management pages</li> <li>Basic OCPP 1.6 support!</li> </ul>"},{"location":"roadmap/#future-plans","title":"Future Plans","text":""},{"location":"roadmap/#16x","title":"1.6.X","text":"<ul> <li>Pursue official OCA Certification for certification profiles beyond Core &amp; Advanced Security</li> </ul>"},{"location":"roadmap/#17x","title":"1.7.X","text":"<ul> <li>Complete OCPP 1.6 support!</li> </ul>"},{"location":"roadmap/#other-topics-for-2025","title":"Other topics for 2025:","text":"<ul> <li>OCPP 2.1 support</li> <li>OCPI 3.0 support</li> <li>OpenADR support - CitrineOS as a Virtual End Node</li> </ul>"},{"location":"roadmap/#contribution","title":"Contribution","text":"<p>We're always looking for contributors to help us improve CitrineOS. If you're interested, please check out our CONTRIBUTING.md guide for more details.</p>"},{"location":"roadmap/#feedback-and-suggestions","title":"Feedback and Suggestions","text":"<p>Your feedback is valuable to us! If you have any suggestions or encounter any issues, please create an issue on our GitHub repository. Note: Please do not create issues on the citrineos-core repository directly moving forward!</p> <p>See something here that you wish was happening sooner, say support for the OCPI 2.2.1 Payment Terminal Whitepaper? Begin working on it! Let us know as well so we can support you and make sure multiple people aren't pursuing the same goals separately.</p> <p>See something that's not here that you think should be? Let us know! Maybe there's a reason, maybe we haven't considered it and we'd love your input and help. This roadmap will grow and change with your feedback.</p> <p>Looking to start making a 3rd-party module now? Let us know now! Although thorough documentation for that process doesn't currently exist, we'd love to start figuring it out with you.</p> <p>The more people interested in helping with development, the more development we can plan.</p> <p>Thank you for being a part of the CitrineOS community! Together, we'll make this project better every day.</p>"},{"location":"core-concepts/adding-id-tokens/","title":"Adding ID Tokens","text":""},{"location":"core-concepts/adding-id-tokens/#adding-id-tokens","title":"Adding ID Tokens","text":"<p>With any CSMS, a valid <code>ID Token</code> must be loaded into the system for charging to be allowed.</p> <p>To quickly do this with CitrineOS, you can run the following <code>cURL</code> command which will invoke CitrineOS's Data API:</p> <pre><code>curl --location --request PUT 'localhost:8080/data/evdriver/authorization?idToken=01&amp;type=Central' \\\n--header 'Content-Type: application/json' \\\n--data '{\n    \"idToken\": {\n        \"idToken\": \"01\",\n        \"type\": \"Central\"\n    },\n    \"idTokenInfo\": {\n        \"status\": \"Accepted\"\n    }\n}'\n</code></pre>"},{"location":"core-concepts/architecture/","title":"Architecture","text":""},{"location":"core-concepts/architecture/#architecture","title":"Architecture","text":"<p>Citrine is an OCPP 2.0.1 Charging Station Management System (CSMS) designed to be adaptable to various infrastructures and easily extensible via modular design. It uses the fastify web framework.</p> <p>Below is a diagram to introduce you to Citrine's high-level architecture: </p> <p>N.B.: In the diagram above the websocket connections pass through the cloud before touching the central system.  The definitions for the central system in 00_Base do not require direct websocket connectivity.  Use of an infrastructure layer between the websockets and central system, such as AWS's API Gateway, is thus supported.  The implementation which lives in Server handles the websockets directly.</p>"},{"location":"core-concepts/architecture/#codebase-structure","title":"Codebase Structure","text":"<p>Citrine's code structure includes 3 common packages: 00_Base, 01_Data, 02_Util and 03_Modules.</p>"},{"location":"core-concepts/architecture/#00_base","title":"00_Base","text":"<p>00_Base defines the interfaces and abstract classes needed for the Module implementations, you can view this as setting the underlying structure that the modules will implement. All OCPP messages and datatypes are here as well.</p>"},{"location":"core-concepts/architecture/#decorators","title":"Decorators","text":"<p>We make use of custom decorators that define methodes to be used for specific logic use cases. - <code>@AsHandler</code>:Defines a method as an OCPP call handler that listens for specific OCPP messages types from the message broker. - <code>@AsMessageEndpoint</code>: Defines a method as a Fastify-exposed API endpoint that takes in HTTP requests that are sent to a charging station. - <code>@AsDataEndpoint</code>: Defines a method as a Fastify-exposed API endpoint that exposes CRUD functionality for entities defined in the 01_Data package.</p>"},{"location":"core-concepts/architecture/#01_data","title":"01_Data","text":"<p>01_Data implements all the logic for Citrine's persistent data, stored in a relational database.  This package is powered by sequelize-typescript.  New modules which add persistent datatypes will need to extend this package.</p>"},{"location":"core-concepts/architecture/#02_util","title":"02_Util","text":"<p>02_Util contains implementations of various infrastructure components and tools.</p> <p>This includes: - Cache implementations, such as redis and a simple Javascript in-memory cache - Message broker implementations such as google pubsub, kafka, and an AMPQP-compatible implementation using amqlib.  - Network connection implementation such as websockets - Swagger plugin for displaying API documentation for all endpoints exposed by Fastify. -  This module can be extended to add additional infrastructure options.</p>"},{"location":"core-concepts/architecture/#03_modules","title":"03_Modules","text":"<p>Citrine is set up that Modules have the actual implementations of OCPP Functional Blocks. They pull in the other packages like 00_base, 01_Data, 02_Util and are built on top.</p> <p>The structure for each module should be roughly the same, set up as: - <code>api.ts</code>: Defines the API endpoints for the module - <code>module.ts</code>: Hold the <code>@AsHandler</code> decorated methods that handle OCPP messages. Here you will also find the supported call actions listed in an array at the top. - <code>service.ts</code>: Offers the deeper logic for the OCPP functional Blocks and is called by the methods in <code>module.ts</code></p>"},{"location":"core-concepts/architecture/#certificates","title":"Certificates","text":"<p>Is responsible for handling certificate management, especially relevant for ISO15118. Certificates are also used to maintain websocket and OTA firmware update security.</p>"},{"location":"core-concepts/architecture/#configuration","title":"Configuration","text":"<p>Handles the configuration of the Charging Station. Example messages are <code>BootNotification</code> and <code>Reset</code>. </p>"},{"location":"core-concepts/architecture/#evdriver","title":"EVDriver","text":"<p>Is responsible for handling driver related functionality, example messages are <code>Authorize</code> and <code>RequestStartTransaction</code>.</p>"},{"location":"core-concepts/architecture/#monitoring","title":"Monitoring","text":"<p>Is responsible for handling Monitoring related functionality. Example message are <code>NotifyEvent</code> and <code>SetVariables</code>.</p>"},{"location":"core-concepts/architecture/#ocpprouter","title":"OCPPRouter","text":"<p>The OCPP router handles the OCPP messages and routes them to and from the correct charger. Furthermore, you can register callbacks for websocket events or specific OCPP messages to be executed in the future.</p>"},{"location":"core-concepts/architecture/#reporting","title":"Reporting","text":"<p>Is responsible for handling Reporting related functionality. Example message are <code>SecurityEventNotification</code> and <code>GetBaseReport</code>.</p>"},{"location":"core-concepts/architecture/#smartcharging","title":"SmartCharging","text":"<p>Is responsible for handling SmartCharging related functionality. Example message are <code>ReportChargingProfiles</code> and <code>SetChargingProfile</code>.</p>"},{"location":"core-concepts/architecture/#transactions","title":"Transactions","text":"<p>Is responsible for handling Transaction related functionality. Example message are <code>TransactionEvent</code> and <code>CostUpdated</code>.</p>"},{"location":"core-concepts/architecture/#server","title":"Server","text":"<p>The server directory is an example implementation using the citrine modules. It is not designed for production use, but rather for local development and test environments. Citrine is designed in a modular fashion scale each module independently. If you want to just use it for local development, check out our guide here: Getting Started</p>"},{"location":"core-concepts/architecture/#other-module-examples","title":"Other Module Examples","text":"<p>Outside of the OCPP 2.0.1 protocol, modules could do things like provide OCPI interfaces, feed data to analysis tools, handle payments, or more.</p>"},{"location":"core-concepts/configuration/","title":"Configuration","text":""},{"location":"core-concepts/configuration/#configuring-citrineos","title":"Configuring CitrineOS","text":""},{"location":"core-concepts/configuration/#introduction","title":"Introduction","text":""},{"location":"core-concepts/configuration/#purpose","title":"Purpose","text":"<p>CitrineOS uses a configuration object, defined in the code as SystemConfig, to define its behavior. This document describes the structure of this object, how to access and modify it, and the meaning of each key-value pair.</p>"},{"location":"core-concepts/configuration/#scope","title":"Scope","text":"<p>The configuration object controls the host and port of all servers in the application as well as optional OCPP features and certain values which can be different from network to network (heartbeat interval, message timeout, etc). Where specific technologies can fill a role in CitrineOS, such as RabbitMQ for the message broker, the configuration object contains the information needed for those technologies.</p>"},{"location":"core-concepts/configuration/#audience","title":"Audience","text":"<p>This is a low-level document for engineers interested in learning more about how to use CitrineOS.</p>"},{"location":"core-concepts/configuration/#configuration-overview","title":"Configuration Overview","text":""},{"location":"core-concepts/configuration/#configuration-management","title":"Configuration Management","text":"<p>By default, CitrineOS uses a typescript file to store system configuration, such as the files in Server/src/config.</p> <p>Environment variables can also be used. They will override the fields in the typescript file when the application starts up. Prefix the variables with 'CITRINEOS', then separate each component of the path to the variable in camel case. Example: CITRINEOS_DATA_SEQUELIZE_USERNAME will override systemConfig.data.sequelize.username with its value.</p> <p>Each module also supports GET and PUT for systemConfig in order to change it while CitrineOS is running. Not all values currently support being changed after application start-up. For example, adding a websocket server to the list after start-up does not currently create a new websocket server.</p>"},{"location":"core-concepts/configuration/#system-configuration","title":"System Configuration","text":"<ul> <li>Env: The environment setting (e.g., development, production).</li> <li>Log Level: The verbosity level of the logging.</li> <li>Max Call Length Seconds: Maximum duration in seconds for a call.</li> <li>Max Caching Seconds: Maximum duration in seconds for caching data.</li> </ul>"},{"location":"core-concepts/configuration/#central-system","title":"Central System","text":"<ul> <li>Host: The hostname for the central system.</li> <li>Port: The port number for the central system.</li> </ul>"},{"location":"core-concepts/configuration/#modules","title":"Modules","text":""},{"location":"core-concepts/configuration/#certificates","title":"Certificates","text":"<ul> <li>Endpoint Prefix: The URL prefix for certificate endpoints.</li> <li>Host: The host where the certificate services are running.</li> <li>Port: The port number for accessing certificate services.</li> </ul>"},{"location":"core-concepts/configuration/#configuration","title":"Configuration","text":"<ul> <li>Heartbeat Interval: The interval in seconds for sending heartbeat messages.</li> <li>Boot Retry Interval: Time interval in seconds before retrying a failed boot process.</li> <li>Unknown Charger Status: Default status for chargers not recognized by the system.</li> <li>Get Base Report On Pending: Boolean flag to get a base report if the status is pending.</li> <li>Boot With Rejected Variables: Boolean flag to attempt booting with rejected variables.</li> <li>Auto Accept: Automatically accept configurations if this is set.</li> <li>Endpoint Prefix: The endpoint URL prefix for configuration modules.</li> <li>Host: Hostname for the configuration service.</li> <li>Port: Port number for the configuration service.</li> </ul>"},{"location":"core-concepts/configuration/#evdriver","title":"EVDriver","text":"<ul> <li>Endpoint Prefix: The endpoint prefix for EV driver communications.</li> <li>Host: The host where the EV driver module is running.</li> <li>Port: The port for EV driver communications.</li> </ul>"},{"location":"core-concepts/configuration/#monitoring","title":"Monitoring","text":"<ul> <li>Endpoint Prefix: The endpoint prefix for monitoring services.</li> <li>Host: The hostname for the monitoring service.</li> <li>Port: The port number for monitoring services.</li> </ul>"},{"location":"core-concepts/configuration/#reporting","title":"Reporting","text":"<ul> <li>Endpoint Prefix: The endpoint prefix used for reporting services.</li> <li>Host: The hostname for the reporting service.</li> <li>Port: The port number for reporting services.</li> </ul>"},{"location":"core-concepts/configuration/#smartcharging","title":"SmartCharging","text":"<ul> <li>Endpoint Prefix: The endpoint prefix for smart charging services.</li> <li>Host: The hostname for smart charging services.</li> <li>Port: The port number for smart charging services.</li> </ul>"},{"location":"core-concepts/configuration/#transactions","title":"Transactions","text":"<ul> <li>Endpoint Prefix: The endpoint prefix for transaction services.</li> <li>Host: The hostname for transaction services.</li> <li>Port: The port number for transaction services.</li> <li>Cost Updated Interval: The interval in seconds for updating the cost information.</li> <li>Send Cost Updated On Meter Value: Whether to send cost updates with meter readings.</li> </ul>"},{"location":"core-concepts/configuration/#data","title":"Data","text":""},{"location":"core-concepts/configuration/#sequelize","title":"Sequelize","text":"<ul> <li>Host: The hostname for the Sequelize database.</li> <li>Port: The port number for the Sequelize database.</li> <li>Database: The name of the database used.</li> <li>Dialect: The type of SQL dialect used (e.g., PostgreSQL, MySQL).</li> <li>Username: The username of the account CitrineOS will use to access the database.</li> <li>Password: The password of the account CitrineOS will use to access the database.</li> <li>Storage: The storage option for Sequelize.</li> <li>Sync: Whether to synchronize the database schema automatically.</li> </ul>"},{"location":"core-concepts/configuration/#util","title":"Util","text":""},{"location":"core-concepts/configuration/#cache","title":"Cache","text":"<ul> <li>Memory: Whether in-memory caching is used.</li> </ul>"},{"location":"core-concepts/configuration/#redis","title":"Redis","text":"<ul> <li>Host: The hostname for the Redis server.</li> <li>Port: The port number for the Redis server.</li> </ul>"},{"location":"core-concepts/configuration/#message-broker","title":"Message Broker","text":""},{"location":"core-concepts/configuration/#pubsub","title":"Pubsub","text":"<ul> <li>Topic Prefix: The prefix for topics in Pub/Sub messaging.</li> <li>Topic Name: The name of the topic that CitrineOS will use.</li> <li>Service Path: Path of the Google Pub/Sub instance. </li> </ul>"},{"location":"core-concepts/configuration/#kafka","title":"Kafka","text":"<ul> <li>Topic Prefix: The prefix for topics.</li> <li>Topic Name: The name of the topic that CitrineOS will use.</li> <li>Brokers: A list of Kafka brokers.</li> <li>SASL:</li> <li>Mechanism: The SASL mechanism used for authentication.</li> <li>Username: The username for SASL authentication.</li> <li>Password: The password for SASL authentication.</li> </ul>"},{"location":"core-concepts/configuration/#amqp","title":"AMQP","text":"<ul> <li>URL: The URL for accessing AMQP services.</li> <li>Exchange: The exchange used in AMQP messaging.</li> </ul>"},{"location":"core-concepts/configuration/#swagger","title":"Swagger","text":"<ul> <li>Path: The URL path for accessing Swagger documentation.</li> <li>Logo Path: The path to the logo used in Swagger documentation.</li> <li>Expose Data: Whether to expose data in Swagger documentation.</li> <li>Expose Message: Whether to expose messaging in Swagger documentation.</li> </ul>"},{"location":"core-concepts/configuration/#network-connection","title":"Network Connection","text":""},{"location":"core-concepts/configuration/#websocket-servers","title":"Websocket Servers","text":"<ul> <li>Id: </li> <li>Host: The hostname for the WebSocket server.</li> <li>Port: The port number for the WebSocket server.</li> <li>Ping Interval: The interval in seconds between pings to keep the connection alive.</li> <li>Protocol: The communication protocol used.</li> <li>Security Profile: The security profile level.</li> <li>Allow Unknown Charging Stations: Whether to allow connections from unknown charging stations.</li> <li>Tls Key File Path: File path to the public key used for tls.</li> <li>Tls Certificate Chain File Path: File path to the server certificate chain for tls.</li> <li>mTls Certificate Authority Key File Path: File path to the CA public key for mtls.</li> <li>Root CA Certificate File Path:: File path to the CA root certificate for mtls.</li> </ul>"},{"location":"core-concepts/configuration/#certificate-authority","title":"Certificate Authority","text":""},{"location":"core-concepts/configuration/#v2g-ca","title":"V2G CA","text":"<ul> <li>Name: The name of the V2G certificate authority.</li> </ul>"},{"location":"core-concepts/configuration/#hubject","title":"Hubject","text":"<ul> <li>Base URL: The base URL for the Hubject V2G services.</li> <li>Token URL: The URL for obtaining a token from Hubject.</li> <li>ISO Version: The ISO standard version supported by Hubject.</li> </ul>"},{"location":"core-concepts/configuration/#charging-station-ca","title":"Charging Station CA","text":"<ul> <li>Name: The name of the charging station certificate authority.</li> </ul>"},{"location":"core-concepts/configuration/#acme","title":"Acme","text":"<ul> <li>Env: The environment setting for Acme services (e.g., staging, production).</li> <li>Account Key File Path: The file path for the account key.</li> <li>Email: The contact email associated with the CA.</li> </ul>"},{"location":"core-concepts/connecting-a-charger/","title":"Connecting a Charger","text":""},{"location":"core-concepts/connecting-a-charger/#connecting-a-charger","title":"Connecting a Charger","text":"<p>If you want to now connect a charger to CitrineOS, you can do so without any set up, just point the charger to <code>ws://localhost:8081</code>. Depending on the charger you are using, you may need to append the station id to the url like so <code>ws://localhost:8081/&lt;stationId&gt;</code>. Some chargers take care of this automatically.</p> <p>The <code>Boot</code> table can be used to both review the most recent boot status as well as set a boot status for the next <code>BootNotificationRequest</code> received from the charging station. After a successful boot, the status is set to <code>Accepted</code>. If you wish to fetch the device model from the charger as part of the boot process described in the B02 use case of part 2 of the OCPP 2.0.1 protocol, set the status to <code>Pending</code> and check the 'Get Base Report On Pending' option. This will cause the next boot to be responded to with a <code>BootNotificationResponse</code> that has status <code>Pending</code>, then CitrineOS will send a <code>GetBaseReportRequest</code>, triggering a series of <code>NotifyReportRequest</code> messages. After the full report has been sent, the next attempted boot by the charger will be <code>Accepted</code>.</p> <p>The <code>Boot</code> table has CRUD endpoints in order to be manipulated via REST API, of which the docs can be found here (if you have CitrineOS running locally): localhost:8080/docs Here is an example request for charge point <code>cp001</code>:</p> <pre><code>curl --location --request PUT 'http://localhost:8080/data/configuration/boot?stationId=cp001' \\\n--header 'Content-Type: application/json' \\\n--data '{ \"status\": \"Pending\" }'\n</code></pre>"},{"location":"core-concepts/connecting-a-charger/#using-security-profile-1","title":"Using Security Profile 1","text":"<p>There are two layers of security available before the charger has the opportunity to send an OCPP message such as <code>BootNotificationRequest</code>. When the charger attempts to connect, it can be rejected at the transport layer if the websocket server is using security profiles 2 or 3. Otherwise, the http upgrade request occurs. The charger's upgrade request can be rejected if:</p> <ul> <li> <p>The request's subprotocol header is incorrect. The default websocket servers used by CitrineOS accept only 'ocpp2.0.1'.</p> </li> <li> <p>The charging station's Id, as set in the url it connected with, is not known. This option can be toggled in the SystemConfig object used by CitrineOS, and is enabled by default only for the security profile 1 websocket server at <code>:8082</code>. To enter a charger into CitrineOS, navigate to the Charging Station collection, then create and save a new entry for your charging station. Make sure the Id of your new entry is the charging station's station id as set in the url it uses to connect to CitrineOS.</p> </li> <li> <p>The websocket server is using security profiles 1 or 2 and the request's Authorization header has an incorrect username or password. The username will be checked against the charging station's id as set in the url it connected with. The password will be checked against the device model associated with the station id. Specifically, it will be the <code>Actual</code> Variable Attribute's value that belongs to the <code>BasicAuthPassword</code> Variable on the <code>SecurityCtrlr</code> Component. You can set this VariableAttribute on the CSMS side using the Variable Attribute CRUD endpoints on the Monitoring module. You can set this VariableAttribute on the Charging Station side using the SetVariables message, which can be sent from CitrineOS using the Monitoring module's message API.</p> </li> </ul> <p>Once a charger has a Charging Station entry and its password has been set, you can connect it to the security profile 1 websocket server at <code>ws://localhost:8082</code>.</p> <p>If you want to add a password for security profile 1 and 2, send the following request to the CitrineOS API.</p> <p><pre><code>curl --location --request POST 'localhost:8080/data/configuration/password?callbackUrl=csms.pro/api/notifications' \\\n--header 'Content-Type: application/json' \\\n--data '{\n  \"stationId\": \"cp001\",\n  \"password\": \"DbkTu048=xueA69@-dB94hjV*fGdyQOzgVuhhH1L\",\n  \"setOnCharger\": false\n}'\n</code></pre> Please note that the <code>password</code> should be sent in plain text and should not be hashed.</p> <p>Set <code>setOnCharger</code> to true if the password has already been updated on the charger and you only need to update the device model associated with the station id. If you need to update the password on the charger (OCPP A01 use case), set <code>setOnCharger</code> to false.</p> <p>Providing a <code>password</code> is mandatory only when <code>setOnCharger</code> is true. This prevents the possibility of updating the device model with an autogenerated password without updating the charger itself.</p> <p>If you do not provide a <code>password</code>, it will be automatically generated. If you do provide one, it must comply with the OCPP specification.</p>"},{"location":"core-concepts/viewing-ocpp-logs/","title":"Viewing OCPP Logs","text":""},{"location":"core-concepts/viewing-ocpp-logs/#viewing-ocpp-logs","title":"Viewing OCPP Logs","text":"<p>With CitrineOS, there are two ways to view OCPP logs.</p> <p>The first way is to view the application logs as directly. This means navigating to either the docker console or the console of wherever CitrineOS was started from.</p> <p>Below is an example of an OCPP log as found in the console:</p> <pre><code>2024-07-25 11:50:40.803 DEBUG   /Documents/citrineos-core/02_Util/src/queue/rabbit-mq/sender.ts:118 CitrineOS Logger:RabbitMqSender Publishing to citrineos: {\n  origin: 'cs',\n  eventGroup: 'general',\n  action: 'BootNotification',\n  context: {\n    stationId: 'CS01',\n    correlationId: '15106be4-57ca-11ee-8c99-0242ac120003',\n    tenantId: '',\n    timestamp: '2024-07-25T11:50:40.803Z'\n  },\n  state: 1,\n  payload: {\n    reason: 'PowerUp',\n    chargingStation: {\n      model: 'SingleSocketCharger',\n      vendorName: 'CS01'\n    }\n  }\n}\n</code></pre> <p>The second approach is to use CitrineOS's Data API to subscribe to OCPP messages. Below is a <code>cURL</code> command that will subscribe the specified URL to all OCPP messages and connection events for charger <code>CS01</code>:</p> <pre><code>curl --request POST 'localhost:8080/data/ocpprouter/subscription' \\\n--header 'Content-Type: application/json' \\\n--data '{\n  \"stationId\": \"CS01\",\n  \"onConnect\": true,\n  \"onClose\": true,\n  \"onMessage\": true,\n  \"sentMessage\": true,\n  \"url\": \"https://2ae3db404d8c.ngrok.app\"\n}'\n</code></pre>"},{"location":"getting-started/getting-started/","title":"Getting Started","text":""},{"location":"getting-started/getting-started/#getting-started-running-citrine-core","title":"Getting Started running Citrine Core","text":"<p>In this section, we assume you have set up the necessary prerequisites.</p>"},{"location":"getting-started/getting-started/#installation","title":"Installation","text":"<p>1. Clone the <code>citrineos/core</code> repository onto your local machine:</p> <pre><code>git clone https://github.com/citrineos/citrineos-core\n</code></pre> <p>2. Navigate to the <code>citrineos-core/Server</code> directory:</p> <pre><code>cd citrineos-core/Server\n</code></pre> <p>3. Start the entire <code>citrineos-core</code> stack with docker-compose:</p> <pre><code>docker compose up -d\n</code></pre> <p>You should now have the following services running:</p> Service URL Description Citrine OCPP HTTP Server http://localhost:8080 See localhost:8080/docs for full details. Citrine OCPP WebSocket Server (Unsecured) ws://localhost:8081 OCPP WebSocket Server running security profile 0. Citrine OCPP WebSocket Server (Secured) wss://localhost:8082 OCPP WebSocket Server running security profile 1. Postgres Database postgressql://citrine:citrine@localhost:5432 Postgres Database pre-seeded with OCPP 2.0.1 schemas. The database is named <code>citrine</code>. RabbitMQ amqp://guest:guest@localhost:5672 RabbitMQ message bus. Redis N/A The default settings will use an in-memory cache but a Redis instance is available to use. <p>Quickly verify the connection to the server by using <code>wscat</code> to send an <code>BootNotification</code>: <pre><code>wscat -c ws://localhost:8081 -x '[\n  2,\n  \"15106be4-57ca-11ee-8c99-0242ac120003\",\n  \"BootNotification\",\n  {\n    \"reason\": \"PowerUp\",\n    \"chargingStation\": {\n      \"model\": \"SingleSocketCharger\",\n      \"vendorName\": \"VendorX\"\n    }\n  }\n]'\n</code></pre></p>"},{"location":"getting-started/getting-started/#configuration","title":"Configuration","text":"<p>We recommend running and developing the project with the <code>docker-compose</code> set-up.</p> <p>However, if you like to rather run it locally and need to adjust where the server is connecting to, please locally adjust the configuration file at <code>./Server/src/config/envs/local.ts</code></p> <p>You can now use the npm run command to start with your environment setup:</p> <pre><code>npm run start\n</code></pre> <p>This command will set the <code>APP_NAME</code> and <code>APP_ENV</code> environment variables; if you wish to set those yourself, you can use <code>npm run start-docker</code>.</p>"},{"location":"getting-started/getting-started/#running-core-with-ocpi","title":"Running CORE with OCPI","text":"<p>To run CORE with OCPI you should follow the steps in the Running OCPI section.</p>"},{"location":"getting-started/making-changes/","title":"Making Changes","text":""},{"location":"getting-started/making-changes/#making-changes-to-citrineos","title":"Making changes to CitrineOS","text":"<p>We recommend using the docker compose setup to ensure a stable and reproducible environment.</p> <p>When making code changes, you should notice that the server automatically rebuilds.  This is because it is started with nodemon.</p>"},{"location":"getting-started/prerequisites/","title":"Prerequisites","text":""},{"location":"getting-started/prerequisites/#prerequisites","title":"Prerequisites","text":""},{"location":"getting-started/prerequisites/#preparing-your-local-environment","title":"Preparing your local environment","text":"<p>Our project is written in Typescript and is based on Node.js. For development purposes you can either run our project fully native on your machine or run it in docker using our <code>docker-compose</code> file. For either path please ensure the following things are installed on your local system:</p> <ul> <li>Node.js: Download Node.js greater than version 18</li> <li>npm (Node Package Manager): Download npm</li> <li>Docker: Download Docker</li> <li>Docker Compose: Install Docker Compose plugin</li> <li>Some sort of CodeEditor or IDE. We have had good experience with VSCode as well as Intelij IDEA.</li> </ul>"},{"location":"getting-started/running-ocpi/","title":"Running OCPI","text":""},{"location":"getting-started/running-ocpi/#running-citrine-with-ocpi","title":"Running Citrine with OCPI","text":"<p>In this section, we assume have gone through the Running CORE section and were able  to run <code>citrineos/core</code>. </p>"},{"location":"getting-started/running-ocpi/#installation","title":"Installation","text":"<p>The setup process for running CORE with OCPI is very similar to running CORE alone.</p> <p>1. Clone the <code>citrineos/ocpi</code> repository onto your local machine:</p> <pre><code>git clone https://github.com/citrineos/citrineos-ocpi\n</code></pre> <p>2. Navigate to the <code>citrineos-ocpi/Server</code> directory:</p> <pre><code>cd citrineos-ocpi/Server\n</code></pre> <p>3. Start the CORE with OCPI with docker-compose:</p> <pre><code>docker compose up -d\n</code></pre> <p>Alternatively, you should also be able to run <code>npm run start-docker-compose</code>, which will use the  <code>./Server/docker-compose.yml</code> configuration to <code>docker compose up</code>.</p> <p>Now along with all of the CORE components, you will also have Citrine OCPI Server localhost:8085 with Swagger UI docs available at localhost:8085/docs.|</p>"},{"location":"getting-started/running-ocpi/#configuration","title":"Configuration","text":"<p>OCPI have very similar structure to CORE, so you would apply configurations changes in the same way. See  Configuration section for more info.</p>"},{"location":"getting-started/testing-with-everest/","title":"Testing with EVerest","text":""},{"location":"getting-started/testing-with-everest/#testing-with-everest","title":"Testing with EVerest","text":"<p>In the case you don't have a charger that supports OCPP 2.0.1 to experiment with, we can recommend using the Linux  Foundation Energy project EVerest. See here for the repository.  They have built an open source version of charger firmware and also allow for using it as a simulator. They support OCPP 2.0.1 which makes it a great testing  opportunity with CitrineOS. For the long route of setting up EVerst you can follow their documentation and build  the project yourself. See here for Docs</p>"},{"location":"getting-started/testing-with-everest/#running-everest","title":"Running EVerest","text":"<p>In order to alleviate some of the complexities that may arise when starting EVerest, we have created some helpful commands that should help in getting the EVerest charger simulator running locally and targeting CitrineOS.</p> <p>You will notice in <code>/Server/everest</code> directory the files created to support running EVerest within Docker. In addition, we created some helpful NPM commands:</p> <ul> <li><code>npm run start-everest</code></li> <li>and</li> <li><code>npm run start-everest-windows</code></li> </ul> <p>Both of which in essence do the same thing which is to trigger the <code>docker compose up</code> command (below) from within the <code>/Server/everest</code> directory so that it can pick up the <code>Dockerfile</code> and the <code>docker-compose.yml</code> files.</p> <p>You will notice that there are two args that are configurable:</p> <ul> <li><code>EVEREST_IMAGE_TAG</code> - The image tag that will be used for the EVerest image (ghcr.io/everest/everest-demo/manager).</li> <li><code>EVEREST_TARGET_URL</code> - The CSMS URL that EVerest will connect to. Defaults to <code>host.docker.internal</code> assuming CitrineOS will run on same machine, since <code>localhost</code> won't work within Docker.</li> </ul> <p>After running <code>npm run start-everest</code> (or the Windows alternative), you should see 3 running EVerest containers and the <code>manager</code> container should have the appropriate EVerest logs.</p>"},{"location":"getting-started/testing-with-everest/#everest-ui","title":"EVerest UI","text":"<p>Now that the 3 containers are running in Docker, you should be able to navigate to <code>[localhost|ip]:1880/ui/</code> to view the EVerest simulator UI. There, you should be able to simulate the pause/resume and plug/unplug events among others.</p>"},{"location":"getting-started/testing-with-everest/#everest-nodered","title":"EVerest NodeRed","text":"<p>You can also view the EVerest NodeRed UI <code>[localhost|ip]:1880/</code>, but it is not advisable to make any adjustments here unless you have a good understanding of this configuration.</p>"},{"location":"getting-started/testing-with-everest/#viewing-ocpp-logs-in-everest","title":"Viewing OCPP logs in EVerest","text":"<p>To view the OCPP logs in EVerest, we have utilized Node <code>http-server</code>, which you will see being initialized in the Dockerfile. We initialize a simple HTTP server on port <code>8888</code> and expose this port so that it is mapped in the compose file allowing you to navigate to <code>localhost:8888</code>. This HTTP server is configured to serve the contents of the <code>/tmp/everest_ocpp_logs</code> which is where EVerest stores the OCPP logs in the Docker container. Conveniently, the logs are in HTML format, so we can easily view them in the browser.</p>"},{"location":"getting-started/testing-with-everest/#running-everest-manually","title":"Running EVerest Manually","text":"<p>You can also use their demo repository that hosts a Docker packaged EVerest image. See here for Github Repo</p> <p>To get EVerest running on the side while developing and making changes, you can follow the steps below. 1. Run your CitrineOS instance locally with <code>docker compose up -d</code> in the CitrineOS repository. 1. Clone the EVerest Demo repository and <code>cd</code> into the repo. 1. With CitrineOS running execute an \"add charger\" script at <code>./citrineos/add-charger.sh</code> This adds a charger, location and password for the charger to CitrineOS. 1. Bring up EVerest with <code>docker compose --project-name everest-ac-demo --file \"docker-compose.ocpp201.yml\" up -d</code>. 1. Copy over the appropriate device model with <code>docker cp manager/device_model_storage_citrineos_sp1.db \\    everest-ac-demo-manager-1:/ext/source/build/dist/share/everest/modules/OCPP201/device_model_storage.db</code>. 1. Start EVerst having OCPP2.0.1 support with <code>docker exec everest-ac-demo-manager-1 sh /ext/source/build/run-scripts/run-sil-ocpp201.sh</code>.</p>"}]}